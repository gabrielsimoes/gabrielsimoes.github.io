<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Notes on &quot;You Don't Know JS&quot; by Kyle Simpson // Gabriel Simões</title><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><link rel="icon" href="/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono|Fira+Sans" media="all"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.0/normalize.min.css" media="all"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" media="all"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlightjs@9.10.0/styles/gruvbox-dark.min.css" media="all"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/simple-line-icons@2.4.1/css/simple-line-icons.min.css" media="all"><link rel="stylesheet" href="/style.css" media="all"></head><body><header><div class="header-top"><img class="my-image" src="/me-bw.png" alt="A picture of me"><p class="my-name">Gabriel Simões</p><p class="my-occupation">Software Developer</p></div><nav><ul class="nav-menu"><li class="nav-item"><a class="nav-item-content" href="/">Home</a></li><li class="nav-item"><a class="nav-item-content" href="/blog.html">Blog</a></li><li class="nav-item"><a class="nav-item-content" href="/reading-watching-list.html">Reading/Watching List</a></li></ul><div class="cv-wrapper"><a class="cv-btn" href="cv.pdf"><span class="icon-doc"> My CV</span></a></div><div class="social-list-wrapper"><ul class="social-list"><li class="social-item" title="simoes.sgabriel@gmail.com"><a href="mailto:simoes.sgabriel@gmail.com"><span class="social-icon icon-envelope"></span></a></li><li class="social-item" title="gabrielsimoes"><a href="https://github.com/gabrielsimoes"><span class="social-icon icon-social-github"></span></a></li><li class="social-item" title="simoes.sgabriel"><a href="https://facebook.com/simoes.sgabriel"><span class="social-icon icon-social-facebook"></span></a></li><li class="social-item" title="gabrielsimoes.github.io"><a href="https://gabrielsimoes.github.io"><span class="social-icon icon-globe"></span></a></li><li class="social-item" title="Atom Feed"><a href="/atom.xml"><span class="social-icon icon-feed"></span></a></li><li class="social-item" title="São Paulo, Brazil"><a href="#"><span class="social-icon icon-location-pin"></span></a></li></ul></div></nav></header><main class="markdown-body"><article><h1 id="notes-on-you-dont-know-js-by-kyle-simpson"><a class="anchor" href="#notes-on-you-dont-know-js-by-kyle-simpson" aria-hidden="true">¶</a> Notes on “You Don’t Know JS” by Kyle Simpson</h1>
<p>The best way to understand and avoid language “gotchas” is by understanding what
causes them. It’s also a great book to learn how to optimize your JS programs
with very little effort.</p>
<p>I have written a good amount of notes over all the six books. Some may find
these too details, some might find them too shallow. Either way, those notes
cover the whole book series and are meant as a review, so I can learn things
more effectively and quickly review some details.</p>
<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="#notes-on-you-dont-know-js-by-kyle-simpson">Notes on “You Don’t Know JS” by Kyle Simpson</a>
<ul>
<li><a href="#up-going">Up &amp; Going</a></li>
<li><a href="#scope-closures">Scope &amp; Closures</a>
<ul>
<li><a href="#scope-and-lexical-scope">Scope and Lexical Scope</a></li>
<li><a href="#function-and-block-scopes">Function and Block Scopes</a></li>
<li><a href="#closures">Closures</a></li>
<li><a href="#arrow-functions-es6">Arrow Functions (ES6)</a></li>
</ul>
</li>
<li><a href="#this-object-prototypes"><code>this</code> &amp; Object Prototypes</a>
<ul>
<li><a href="#this"><code>this</code></a></li>
<li><a href="#objects">Objects</a></li>
<li><a href="#mixins">Mixins</a></li>
<li><a href="#prototypes">Prototypes</a></li>
<li><a href="#behavior-delegationoloo-objects-linked-to-other-objects">Behavior Delegation/OLOO (objects-linked-to-other-objects)</a></li>
<li><a href="#es6-class">ES6 <code>class</code></a></li>
</ul>
</li>
<li><a href="#types-grammar">Types &amp; Grammar</a>
<ul>
<li><a href="#types">Types</a></li>
<li><a href="#values">Values</a>
<ul>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#numbers">Numbers</a></li>
<li><a href="#void-operator"><code>void</code> operator</a></li>
<li><a href="#value-vs-reference">Value vs. Reference</a></li>
</ul>
</li>
<li><a href="#natives">Natives</a></li>
<li><a href="#coercion">Coercion</a>
<ul>
<li><a href="#explicit-coercion">Explicit Coercion</a></li>
<li><a href="#implicit-coercion">Implicit Coercion</a></li>
<li><a href="#loosestrict-equals">Loose/Strict Equals</a></li>
</ul>
</li>
<li><a href="#grammar">Grammar</a></li>
</ul>
</li>
<li><a href="#async-performance">Async &amp; Performance</a>
<ul>
<li><a href="#async">Async</a></li>
<li><a href="#performance">Performance</a></li>
</ul>
</li>
<li><a href="#es6-beyond">ES6 &amp; Beyond</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="up-going"><a class="anchor" href="#up-going" aria-hidden="true">¶</a> Up &amp; Going</h2>
<p>This first book is great for getting started into the series, specially if you
have a shallow understanding of JS internals. That is because each of the other
books will assume you have some basic understanding of the language mechanisms
explained deeply in the other books of the series.</p>
<p>But if you already have a good understanding of the language, maybe it’s best to
just skip to the other books.</p>
<p>Always use the <code>&quot;use strict&quot;;</code> in your code. Keeps code safer and optimized.</p>
<h2 id="scope-closures"><a class="anchor" href="#scope-closures" aria-hidden="true">¶</a> Scope &amp; Closures</h2>
<h3 id="scope-and-lexical-scope"><a class="anchor" href="#scope-and-lexical-scope" aria-hidden="true">¶</a> Scope and Lexical Scope</h3>
<ul>
<li>JavaScript compiles statements kind-of individually and shortly before they
are executed. JS engines also use JIT, lazy compilation and hot compilation.</li>
<li>We can devide JavaScript compilation in three “characters”: Engine, Compiler
and Scope.</li>
<li>Types of Scope look-ups:
<ul>
<li><em>LHS</em>: when the variable is the target of the assignment. If it doesn’t
exist, the <code>Scope</code> creates a new global variable (when strict mode is not
enabled). If strict mode is enabled, it will throw a <code>ReferenceError</code>.</li>
<li><em>RHS</em>: when the variable is the source of the assigment. <code>Engine</code> wants the
value of the variable. If it doesn’t exist, it will throw a
<code>ReferenceError</code>.</li>
</ul>
</li>
<li>JavaScript scopes by using <em>Lexical Scope</em>, as opposed to <em>Dynamic Scope</em>.
This means that the scopes are nested and are solely determined by the code
structure, rather than by the execution stack.</li>
<li>Lexical scope can be cheated at runtime through <code>eval</code> and <code>with</code>, but they
are almost completely disabled in strict mode and the simple fact you are
using them will disable several optimizations. So, <em>don’t use them</em>.</li>
</ul>
<h3 id="function-and-block-scopes"><a class="anchor" href="#function-and-block-scopes" aria-hidden="true">¶</a> Function and Block Scopes</h3>
<ul>
<li>Author recommends using named functions all the time, even in expressions.
Improves code readability and also stack traces.</li>
<li>JavaScript only restricts variable scope inside functions:<pre><code class="language-javascript hljs"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;
}

(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> b = <span class="hljs-number">42</span>; })();

<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// I can access a.</span>
<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// Error.</span>
</code></pre>
</li>
<li>You should follow the “Principle of Least <s>Privilege</s> Exposure”.</li>
<li><em>IIFEs</em> (Immediately Invoked Function Expressions):
<ul>
<li><code>(function() { ... })();</code></li>
<li><code>(function() { ... }());</code></li>
<li><code>(function(foo) { foo(&quot;bar&quot;); })(function(str) { ... });</code></li>
</ul>
</li>
<li>Use the ES6 keyword <code>let</code> to do block-scoping:<pre><code class="language-javascript hljs">{
  <span class="hljs-keyword">let</span> foo = <span class="hljs-string">"bar"</span>;
}

<span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// ReferenceError</span>
</code></pre>
</li>
<li>Variables declared with <code>let</code> are never hoisted.</li>
<li>This also improves performance, as values are garbage collected earlier.</li>
<li>The <code>const</code> keyword works just like <code>let</code>, but is used for constants.</li>
<li>This ES6 behaviour is transpilled using <code>try/catch</code> blocks.</li>
<li>JavaScript does hoisting with functions and variables. Functions first:<pre><code class="language-javascript hljs">foo();

<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">// Declaration will go up, but not assignment.</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// This will go above everything.</span>
  <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined -- only "a" declaration was hoisted.</span>
}
</code></pre>
</li>
</ul>
<h3 id="closures"><a class="anchor" href="#closures" aria-hidden="true">¶</a> Closures</h3>
<ul>
<li>Loops + Closure:
This code prints <code>6</code> five times:<pre><code class="language-javascript hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) {
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(i); }, i*<span class="hljs-number">100</span>);
}
</code></pre>
You can solve this by using a closure:<pre><code class="language-javascript hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) {
  (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> j = i;
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(j); }, j*<span class="hljs-number">100</span>);
  })();
}
</code></pre>
You can solve this using <code>let</code>:<pre><code class="language-javascript hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) {
  <span class="hljs-comment">// you could use the `let j = i;` trick here, but...</span>
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(i); }, i*<span class="hljs-number">100</span>);
}
</code></pre>
There’s a <em>special behaviour</em> defined for <code>let</code> declarations used in the head
of a for-loop: the variable is declared <em>each iteration</em> and it’s initialized
with the value from the previous iteration.</li>
<li><em>Closures</em>: when a function can remember and access its lexical scope even
when it’s invoked outside its lexical scope.</li>
<li><em>Modules</em> require two characteristics:
<ul>
<li>An outer wrapper function being invoked, to create the enclosing scope.</li>
<li>The return value of the function should include a reference to at least one
inner function that then has closure over the private inner scope.</li>
</ul>
<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> foo = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyCoolModule</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> a, b, c;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{ ... };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAnother</span>(<span class="hljs-params"></span>) </span>{ ... };

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">doSomething</span>: doSomething,
    <span class="hljs-attr">doAnother</span>: doAnother
  };
})();
</code></pre>
</li>
<li>You can use ES6 file modules through <code>export</code>, <code>import</code> and <code>module</code>.</li>
</ul>
<h3 id="arrow-functions-es6"><a class="anchor" href="#arrow-functions-es6" aria-hidden="true">¶</a> Arrow Functions (ES6)</h3>
<ul>
<li>They bind <code>this</code> to the lexical context they are in:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> id = <span class="hljs-string">"not awesome"</span>;

<span class="hljs-keyword">var</span> bad = {
  <span class="hljs-attr">id</span>: <span class="hljs-string">"awesome"</span>,
  <span class="hljs-attr">cool</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">coolFn</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.id);
  }
};

<span class="hljs-keyword">var</span> good1 = {
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">cool</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">coolFn</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &lt; <span class="hljs-number">1</span>) {
      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">// arrow-function ftw?</span>
        <span class="hljs-keyword">this</span>.count++;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"awesome?"</span>);
      }, <span class="hljs-number">100</span> );
    }
  }
};

<span class="hljs-keyword">var</span> good2 = {
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">cool</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">coolFn</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &lt; <span class="hljs-number">1</span>) {
      setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timer</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">this</span>.count++; <span class="hljs-comment">// `this` is safe because of `bind(..)`</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"more awesome"</span>);
      }.bind(<span class="hljs-keyword">this</span>), <span class="hljs-number">100</span> ); <span class="hljs-comment">// look, `bind()`!</span>
    }
  }
};

bad.cool(); <span class="hljs-comment">// awesome</span>
setTimeout(bad.cool, <span class="hljs-number">100</span>); <span class="hljs-comment">// not awesome</span>
good1.cool(); <span class="hljs-comment">// awesome?</span>
good2.cool(); <span class="hljs-comment">// more awesome</span>
</code></pre>
</li>
</ul>
<h2 id="this-object-prototypes"><a class="anchor" href="#this-object-prototypes" aria-hidden="true">¶</a> <code>this</code> &amp; Object Prototypes</h2>
<h3 id="this"><a class="anchor" href="#this" aria-hidden="true">¶</a> <code>this</code></h3>
<ul>
<li>
<p><code>this</code> <em>isn’t</em> a reference to the function itself.</p>
</li>
<li>
<p><code>this</code> <em>isn’t</em> a reference to the function’s lexical scope.</p>
</li>
<li>
<p><code>this</code> <em>is</em> a binding that is made when a function is <em>invoked</em>, and what it
references is determined by the call-site.</p>
</li>
<li>
<p>There are four rules for how <code>this</code> gets set:</p>
<pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.bar);
}

<span class="hljs-keyword">var</span> bar = <span class="hljs-string">"global"</span>;

<span class="hljs-keyword">var</span> obj1 = {
  <span class="hljs-attr">bar</span>: <span class="hljs-string">"obj1"</span>,
  <span class="hljs-attr">foo</span>: foo
};

<span class="hljs-keyword">var</span> obj2 = {
  <span class="hljs-attr">bar</span>: <span class="hljs-string">"obj2"</span>
};

foo();            <span class="hljs-comment">// "global"</span>
obj1.foo();       <span class="hljs-comment">// "obj1"</span>
foo.call( obj2 ); <span class="hljs-comment">// "obj2"</span>
<span class="hljs-keyword">new</span> foo();        <span class="hljs-comment">// undefined</span>
</code></pre>
<ol>
<li><em>Default Binding</em>: Standalone function invocation. In the example above,
<code>foo()</code> ends up setting this to the global object in non-strict mode. In
strict mode, <code>this</code> would be undefined.</li>
<li><em>Implicit Binding</em>: The call-site has a context object. In the example
above, <code>obj1.foo()</code> sets <code>this</code> to the <code>obj1</code> object.</li>
<li><em>Explicit Binding</em>: Using <code>fn.call()</code>, <code>fn.apply()</code> or ES5’s <code>fn.bind()</code>.
In the example above, <code>foo.call(obj2)</code> sets <code>this</code> to the <code>obj2</code> object.
Some API functions have a parameter “context” to be bound in callbacks.</li>
<li><em><code>new</code> Binding</em>: When a function is called with <code>new</code>, a brand new object
is created and set as <code>this</code>. Unless the function returns something, the
new object is returned. In the example above, <code>new foo()</code> sets <code>this</code> to a
brand new empty object.</li>
</ol>
</li>
<li>
<p><em>Binding exceptions</em>:</p>
<ul>
<li>Passing <code>null</code> or <code>undefined</code> to <code>call</code>, <code>apply</code> or <code>bind</code>. Use instead:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> ø = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>); <span class="hljs-comment">// a "DMZ" empty object</span>
fn.bind(ø);
</code></pre>
</li>
<li>Indirection: <code>(p.foo = o.foo)();</code></li>
</ul>
</li>
<li>
<p><em>“Soft Binding”</em>:
Allows overriding with Implicit/Explicit Binding.</p>
<pre><code class="language-javascript hljs"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Function</span>.prototype.softBind) {
  <span class="hljs-built_in">Function</span>.prototype.softBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">this</span>,
      curried = [].slice.call( <span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span> ),
      bound = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bound</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> fn.apply(
          (!<span class="hljs-keyword">this</span> ||
            (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">"undefined"</span> &amp;&amp;
              <span class="hljs-keyword">this</span> === <span class="hljs-built_in">window</span>) ||
            (<span class="hljs-keyword">typeof</span> global !== <span class="hljs-string">"undefined"</span> &amp;&amp;
              <span class="hljs-keyword">this</span> === global)
          ) ? obj : <span class="hljs-keyword">this</span>,
          curried.concat.apply( curried, <span class="hljs-built_in">arguments</span> )
        );
      };
    bound.prototype = <span class="hljs-built_in">Object</span>.create( fn.prototype );
    <span class="hljs-keyword">return</span> bound;
  };
}
</code></pre>
</li>
<li>
<p>It is possible to do lexical binding through arrow functions, but the author
discourages it.</p>
</li>
</ul>
<h3 id="objects"><a class="anchor" href="#objects" aria-hidden="true">¶</a> Objects</h3>
<ul>
<li>In objects, property names are <em>always strings</em>:<pre><code class="language-javscript hljs">myObject[myObject] = 42;
myObject[&quot;[object Object]&quot;]; // 42
</code></pre>
</li>
<li>ES6 computed property names:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> prefix = <span class="hljs-string">"foo"</span>;

<span class="hljs-keyword">var</span> myObject = {
  [prefix + <span class="hljs-string">"bar"</span>]: <span class="hljs-string">"hello"</span>,
  [prefix + <span class="hljs-string">"baz"</span>]: <span class="hljs-string">"world"</span>
};

myObject[<span class="hljs-string">"foobar"</span>]; <span class="hljs-comment">// hello</span>
myObject[<span class="hljs-string">"foobaz"</span>]; <span class="hljs-comment">// world</span>
</code></pre>
</li>
<li>Methods “don’t exist” in JS, only references to functions.</li>
<li>Duplicating objects.
<ul>
<li>JSON-safe objects:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj));
</code></pre>
</li>
<li>Shallow copy (ES6):<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">Object</span>.assign({}, obj);
</code></pre>
</li>
</ul>
</li>
<li>Property Descriptors: <code>Object.getOwnPropertyDescriptor</code>,
<code>Object.defineProperty</code>. The descriptors are: <code>writable</code>, <code>configurable</code> and
<code>enumberable</code>.</li>
<li><code>Object.preventExtensions</code>, <code>Object.seal</code>, <code>Object.freeze</code> to make “immutable”
objects.</li>
<li><code>[[Get]]</code> and <code>[[Set]]</code> characteristics of a property:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> obj = {
  get a() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._a_; },
  set a(val) { <span class="hljs-keyword">this</span>._a_ = val * <span class="hljs-number">2</span>; }
};

<span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">"b"</span>, {
  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a * <span class="hljs-number">2</span> },
  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
});

obj.a = <span class="hljs-number">1</span>;
obj.a; <span class="hljs-comment">// 2;</span>
obj.b; <span class="hljs-comment">// 4;</span>
</code></pre>
</li>
<li>Test for existence: <code>(&quot;a&quot; in obj);</code> (includes prototypes),
<code>obj.hasOwnProperty(&quot;a&quot;)</code>.</li>
<li>Array of keys: <code>Object.keys</code> (enumerable only), <code>Object.getOwnPropertyNames</code>.</li>
<li>Iterate over keys: <code>for..in</code> loop (includes prototypes). Use in objects, not
arrays. Also: <code>obj.forEach</code>, <code>obj.every</code> and <code>obj.some</code>.</li>
<li>Iterate over values (ES6): <code>for..of</code>.
<ul>
<li>Works by accessing the built-in <code>@@iterator</code>:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> it = myArray[<span class="hljs-built_in">Symbol</span>.iterator]();
it.next(). <span class="hljs-comment">// {value: 42, done: false}</span>
</code></pre>
</li>
<li>It is possible to define custom iterators for objects:<pre><code class="language-javascript hljs"><span class="hljs-built_in">Object</span>.defineProperty( myObject, <span class="hljs-built_in">Symbol</span>.iterator, {
  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">this</span>, i = <span class="hljs-number">0</span>, k = <span class="hljs-built_in">Object</span>.keys(o);
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> {;
          value: o[k[i++]],
          <span class="hljs-attr">done</span>: (i &gt; k.length)
        };
      }
    };
  }
});
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="mixins"><a class="anchor" href="#mixins" aria-hidden="true">¶</a> Mixins</h3>
<ul>
<li>JS has no notion of classes/inheritance/polymorphism.</li>
<li>Developers use mixings instead:<pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mixin</span>(<span class="hljs-params">sourceObj, targetObj</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> sourceObj) {
    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> targetObj)) {
      targetObj[key] = sourceObj[key];
    }
  }

  <span class="hljs-keyword">return</span> targetObj;
}
</code></pre>
</li>
<li>This leads to “explicit pseudo-polymorphism” (which the author discourages):<pre><code class="language-javascript hljs">sourceObj.methodName.call(<span class="hljs-keyword">this</span>, ...);
</code></pre>
</li>
<li>Explicit mixings are not exactly the same as class <em>copy</em>.</li>
<li>“Parasitic Inheritance”: calling <code>new Parent()</code> inside <code>new Child()</code>.</li>
<li>“Implicit Mixings”: “borrowing” methods through “implicit binding”.</li>
</ul>
<h3 id="prototypes"><a class="anchor" href="#prototypes" aria-hidden="true">¶</a> Prototypes</h3>
<ul>
<li><code>Object.create(obj)</code> (ES5) creates a object with <code>obj</code> in <code>[[Prototype]]</code>
linkage.</li>
<li><code>Object.prototype</code> is at the top of every “<em>normal</em>” <code>[[Prototype]]</code> chain.</li>
<li>Shadowing only occurs if the property found in the <code>[[Prototype]]</code> chain is
writable and it is not a setter.</li>
<li>A function’s <code>Foo.prototype</code> gets linked to the <code>[[Prototype]]</code> chain of an
object created with <code>new Foo();</code>:<pre><code class="language-javascript hljs"><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-keyword">new</span> Foo()) === Foo.prototype; <span class="hljs-comment">// true</span>
</code></pre>
</li>
<li><code>Foo.prototype</code> and the created object (through <code>[[Prototype]]</code>) get a
<code>.constructor</code> property:<pre><code class="language-javascript hljs">Foo.prototype.constructor === Foo; <span class="hljs-comment">// true</span>
(<span class="hljs-keyword">new</span> Foo()).constructor === Foo; <span class="hljs-comment">// true</span>
</code></pre>
</li>
<li>However, <code>.constructor</code> is unreliable and should be avoided where possible.</li>
<li>We’re are not actually <em>copying</em> but <em>linking</em> “classes”.</li>
<li>How to simulate class-orientation then? Example from the book:<pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">this</span>.name = name;
}

Foo.prototype.myName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">name,label</span>) </span>{
  Foo.call(<span class="hljs-keyword">this</span>, name);
  <span class="hljs-keyword">this</span>.label = label;
}

<span class="hljs-comment">// here, we make a new `Bar.prototype`</span>
<span class="hljs-comment">// linked to `Foo.prototype`</span>
Bar.prototype = <span class="hljs-built_in">Object</span>.create(Foo.prototype);

<span class="hljs-comment">// Beware! Now `Bar.prototype.constructor` is gone,</span>
<span class="hljs-comment">// and might need to be manually "fixed" if you're</span>
<span class="hljs-comment">// in the habit of relying on such properties!</span>

Bar.prototype.myLabel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.label;
};

<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Bar(<span class="hljs-string">"a"</span>, <span class="hljs-string">"obj a"</span>);

a.myName(); <span class="hljs-comment">// "a"</span>
a.myLabel(); <span class="hljs-comment">// "obj a"</span>
</code></pre>
</li>
<li>Alternatives to <code>Bar.prototype = Object.create(Foo.prototype);</code>:
<ul>
<li><code>Bar.prototype = Foo.prototype;</code>: not a copy, will modify <code>Foo.prototype</code>.</li>
<li><code>Bar.prototype = new Foo();</code>: if <code>Foo()</code> has side-effects, they will happen.</li>
<li>ES6’s <code>Object.setPrototypeOf(Bar.prototype, Foo.prototype);</code>: works well.</li>
</ul>
</li>
<li><code>a instanceof Foo</code> tests whether <code>Foo.prototype</code> appears in the
<code>[[Prototype]]</code> chain of <code>a</code>.</li>
<li>Functions hard-bound with <code>.bind(..)</code> loose their <code>.prototype</code> property.</li>
<li>A much cleaner approach is to use <code>Foo.prototype.isPrototypeOf(a)</code>.</li>
<li>Retrieve <code>[[Prototype]]</code> of an object: <code>Object.getPrototypeOf(a);</code> (ES5) or
<code>a.__proto__</code>.</li>
<li>You <em>should not</em> change the <code>[[Prototype]]</code> of an existing object.</li>
</ul>
<h3 id="behavior-delegationoloo-objects-linked-to-other-objects"><a class="anchor" href="#behavior-delegationoloo-objects-linked-to-other-objects" aria-hidden="true">¶</a> Behavior Delegation/OLOO (objects-linked-to-other-objects)</h3>
<ul>
<li>An alternative way of thinking/designing software in JS, which the author
thinks is better than Object Orientation.</li>
<li>Objects <em>delegate</em> common behaviour to a common prototype through <code>Object.create(..)</code>.</li>
<li>You want <em>state</em> to be on the <em>delegators</em>.</li>
<li><em>We avoid if at all possible naming things the same</em> at different levels of the <code>[[Prototype]]</code> chain.</li>
<li>Code gets much nicer when using <code>Object.setPrototypeOf(obj, prototypeObj)</code>.</li>
<li>We often can eliminate base classes, because behavior delegation suggests
objects as peer of each other.</li>
</ul>
<h3 id="es6-class"><a class="anchor" href="#es6-class" aria-hidden="true">¶</a> ES6 <code>class</code></h3>
<ul>
<li>No need for <code>.prototype</code> references in the code.</li>
<li><code>extends</code> keyword provides inheritance. It is also possible to extend built-in
objects.</li>
<li><code>constructor</code> method provides “instantiation”.</li>
<li><code>super(..)</code> and <code>super.fn(..)</code> provide “<em>relative polmorphism</em>”.</li>
<li>No need for commas.</li>
<li><em>However</em>, it works mostly the same way as the <code>[[Prototype]]</code> mechanism.</li>
<li><em>But</em> it makes some things “static” where otherwise they would be dynamic.</li>
</ul>
<h2 id="types-grammar"><a class="anchor" href="#types-grammar" aria-hidden="true">¶</a> Types &amp; Grammar</h2>
<h3 id="types"><a class="anchor" href="#types" aria-hidden="true">¶</a> Types</h3>
<ul>
<li>JavaScript has only seven built-in types: <code>string</code>, <code>number</code>, <code>boolean</code>,
<code>null</code>, <code>undefined</code>, <code>object</code> and <code>symbol</code> (introduced in ES6).</li>
<li>All are called “primitives”, except for <code>object</code>.</li>
<li><code>typeof</code> has a long-standing bug, but there is a workaround.<pre><code class="language-javascript hljs"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// "object"`</span>

<span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;
(!a &amp;&amp; <span class="hljs-keyword">typeof</span> a === <span class="hljs-string">"object"</span>); <span class="hljs-comment">// true</span>
</code></pre>
</li>
<li><code>function</code> is a (special) subtype of <code>object</code>:<pre><code class="language-javascript hljs"><span class="hljs-keyword">typeof</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; } <span class="hljs-comment">// "function"</span>

<span class="hljs-comment">// but:</span>
<span class="hljs-keyword">typeof</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-comment">// "object"</span>
</code></pre>
</li>
<li>“In JS, variables don’t have types – values have types.”</li>
<li>We can use <code>typeof</code> to prevent errors with undeclared variables, without
resorting to the global <code>window</code> object:<pre><code class="language-javascript hljs"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> FLAG !== <span class="hljs-string">"undefined"</span>) {}
<span class="hljs-comment">// or:</span>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.FLAG) {}
</code></pre>
</li>
</ul>
<h3 id="values"><a class="anchor" href="#values" aria-hidden="true">¶</a> Values</h3>
<h4 id="arrays"><a class="anchor" href="#arrays" aria-hidden="true">¶</a> Arrays</h4>
<ul>
<li><code>delete</code> removes slots but does not update <code>.length</code>.</li>
<li>Adding named properties to arrays doesn’t affect the <code>length</code> property, except
if the property “looks like a number”: <code>myArray[&quot;42&quot;] = &quot;foo&quot;;</code>.</li>
<li>Empty slots are left in this case. They return <code>undefined</code> when accessed.</li>
<li>Build arrays from “array-likes”:<pre><code class="language-javascript hljs"><span class="hljs-built_in">Array</span>.prototype.slice.call([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-comment">// or (ES6):</span>
<span class="hljs-built_in">Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// [1, 2, 3]</span>
</code></pre>
</li>
</ul>
<h4 id="strings"><a class="anchor" href="#strings" aria-hidden="true">¶</a> Strings</h4>
<ul>
<li>JS <code>string</code>s are immutable.</li>
<li>There are some array-like methods, but other array methods are not available.</li>
<li>It is possible to “borrow” some <code>array</code> methods:<pre><code class="language-javascript hljs"><span class="hljs-built_in">Array</span>.prototype.join.call(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"-"</span>); <span class="hljs-comment">// "f-o-o"</span>
<span class="hljs-built_in">Array</span>.prototype.map.call(<span class="hljs-string">"foo"</span>, v =&gt; v.toUpperCase() + <span class="hljs-string">"."</span>).join(<span class="hljs-string">""</span>); <span class="hljs-comment">// "F.O.O."</span>
</code></pre>
</li>
</ul>
<h4 id="numbers"><a class="anchor" href="#numbers" aria-hidden="true">¶</a> Numbers</h4>
<ul>
<li>JS <code>number</code>s use the “IEEE 754” standard (“double precision”), often called
“floating-point.”</li>
<li>Comparisons can fail due to imprecision. Use the <code>Number.EPSILON</code> (ES6) or
<code>2^-52</code> to test equality.</li>
<li>Safe integers (no errors): <code>Number.MAX_SAFE_INTEGER</code> or <code>2^53 -1</code>.</li>
<li>Force a <code>number</code> into a 32-bit signed integer: <code>x | 0</code>. (bitwise operation).</li>
<li>Special numbers:
<ul>
<li><code>NaN</code>:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span> / <span class="hljs-string">"foo"</span>;

a == <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// false</span>
a === <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// false -- comparisons with NaN always return false.</span>

<span class="hljs-comment">// we can use isNaN(..), but it has gotchas:</span>
<span class="hljs-built_in">isNaN</span>(a); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">"foo"</span>) <span class="hljs-comment">// true</span>

<span class="hljs-comment">// ES6:</span>
<span class="hljs-built_in">Number</span>.isNaN(a); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">Number</span>.isNan(<span class="hljs-string">"foo"</span>); <span class="hljs-comment">// false</span>
</code></pre>
</li>
<li><code>Infinity</code> and <code>-Infinity</code>:<pre><code class="language-javascript hljs"><span class="hljs-number">1</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// Infinity</span>
<span class="hljs-number">-1</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// -Infinity</span>
<span class="hljs-number">1e1000000</span>; <span class="hljs-comment">// Infinity</span>
<span class="hljs-number">2</span> * <span class="hljs-built_in">Number</span>.MAX_VALUE; <span class="hljs-comment">// Infinity</span>
</code></pre>
</li>
<li><code>-0</code>: happens as result of some operations, but behaves almost like <code>0</code>:<pre><code class="language-javascript hljs"><span class="hljs-number">-0</span> === <span class="hljs-number">0</span>; <span class="hljs-comment">// true</span>
(<span class="hljs-number">-0</span> === <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-number">1</span> / <span class="hljs-number">-0</span> === -<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// true -- can be used to test for -0</span>
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="void-operator"><a class="anchor" href="#void-operator" aria-hidden="true">¶</a> <code>void</code> operator</h4>
<ul>
<li>“voids” out any value: <code>void &quot;foo&quot;; // undefined</code></li>
</ul>
<h4 id="value-vs-reference"><a class="anchor" href="#value-vs-reference" aria-hidden="true">¶</a> Value vs. Reference</h4>
<ul>
<li>Simple scalar primitives (<code>string</code>s, <code>number</code>s, etc.) are assigned/passed by
value-copy.</li>
<li>Compound values (<code>object</code>s, etc.) are assigned/passed by reference-copy.</li>
<li>References are not like references/pointers in other languages. They point to
the underlying values and not to the variables themselves:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> b = a;

b.push(<span class="hljs-number">4</span>);
a; <span class="hljs-comment">// [1, 2, 3, 4]</span>

b = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
a; <span class="hljs-comment">// [1, 2, 3, 4]</span>

b = a.slice();
b.push(<span class="hljs-number">5</span>);
a; <span class="hljs-comment">// [1, 2, 3, 4]</span>
b; <span class="hljs-comment">// [1, 2, 3, 4, 5]</span>
</code></pre>
</li>
<li>Be careful with object wrappers:<pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>{
  x++;
  <span class="hljs-built_in">console</span>.log(x);
}

<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Number</span>(<span class="hljs-number">42</span>);
foo(a); <span class="hljs-comment">// 43</span>
a; <span class="hljs-comment">// 42</span>
</code></pre>
Even though we’re passing the reference, the underlying value is unboxed from
the <code>Number</code> object in the addition operation.</li>
</ul>
<h3 id="natives"><a class="anchor" href="#natives" aria-hidden="true">¶</a> Natives</h3>
<ul>
<li>
<p>Object sub-types/built-in objects/natives: <code>String()</code>, <code>Number()</code>,
<code>Boolean()</code>, <code>Array()</code>, <code>Object()</code>, <code>Function()</code>, <code>RegExp()</code>, <code>Date()</code>,
<code>Error()</code>, <code>Symbol()</code> (added in ES6).</p>
</li>
<li>
<p>JavaScript automatically coerces primitives to their corresponding objects
when accessing properties/methods:</p>
<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> strPrimitive = <span class="hljs-string">"I am a string"</span>;
<span class="hljs-built_in">console</span>.log(strPrimitive.length);    <span class="hljs-comment">// 13</span>
<span class="hljs-built_in">console</span>.log(strPrimitive.charAt(<span class="hljs-number">3</span>)); <span class="hljs-comment">// "m"</span>
</code></pre>
</li>
<li>
<p>The following objects have corresponding primitives: <code>String</code>, <code>Number</code>,
<code>Boolean</code>.</p>
</li>
<li>
<p><code>null</code> and <code>undefined</code> have no object wrapper form.</p>
</li>
<li>
<p><code>Object</code>, <code>Function</code>, <code>Array</code> and <code>RegExp</code> are object-only, though you should
prefer their literal form.</p>
</li>
<li>
<p><code>Date</code> and <code>Error</code> can only be created through their constructed object form.</p>
</li>
<li>
<p>You should never wrap primitive values manually.</p>
</li>
<li>
<p>There are gotchas, like this one: <code>!(new Boolean(false)); // false</code>.</p>
</li>
<li>
<p>Unboxing: <code>.valueOf()</code>.</p>
</li>
<li>
<p><em>Never use empty-slot arrays</em>. They are full ob bugs/inconsistencies</p>
</li>
<li>
<p>If you want to create an array with “empty” slots, use this:</p>
<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, {<span class="hljs-attr">length</span>: <span class="hljs-number">3</span>});
</code></pre>
<p>It’ll create an array with 3 slots filled with <code>undefined</code>, which is more
reliable then using <code>Array(3)</code> or setting the <code>.length</code> property to 3.</p>
</li>
<li>
<p>You probably should never use <code>Object(..)</code>, <code>Function(..)</code>, and <code>RegExp(..)</code>.</p>
</li>
<li>
<p>Except if you want to pass flags to <code>RegExp(..)</code>, like this:</p>
<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> namePattern = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"\\b(?:"</span> + name + <span class="hljs-string">")+\\b"</span>, <span class="hljs-string">"ig"</span> );
</code></pre>
</li>
</ul>
<h3 id="coercion"><a class="anchor" href="#coercion" aria-hidden="true">¶</a> Coercion</h3>
<ul>
<li>ToString: <code>a + &quot;&quot;</code>, <code>String(..)</code>, <code>.toString()</code> or <code>JSON.stringify(..)</code></li>
<li>ToNumber: <code>Number(..)</code></li>
<li>ToBoolean: <code>Boolean(..)</code></li>
<li>“Falsy” values:
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>+0</code>, <code>-0</code>, and <code>NaN</code></li>
<li><code>&quot;&quot;</code></li>
</ul>
</li>
<li>Due to legacy reasons, all these coerce to <code>true</code>:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">0</span>);
<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">""</span>);
</code></pre>
</li>
</ul>
<h4 id="explicit-coercion"><a class="anchor" href="#explicit-coercion" aria-hidden="true">¶</a> Explicit Coercion</h4>
<ul>
<li><strong>Strings &lt;–&gt; Numbers</strong>: <code>String(42)</code> and <code>Number(&quot;42&quot;)</code>.
<ul>
<li><em>Important</em>: Don’t use the <code>new</code> keyword, to avoid creating an object.</li>
<li>Alternative ways: <code>(42).toString()</code> and <code>+&quot;42&quot;</code></li>
<li><code>parseInt(..)</code> and <code>parseFloat(..)</code> are tolerant to non-numeric characters.</li>
<li>Date --&gt; Number: works the same way, the result is the unix timestamp.
<ul>
<li>A explicit approach is better: <code>.getTime()</code>. or <code>Date.now()</code> (ES5).</li>
</ul>
</li>
</ul>
</li>
<li><strong>–&gt; Boolean</strong>: <code>!!x</code> or <code>Boolean(..)</code> (former is preferred)</li>
</ul>
<h4 id="implicit-coercion"><a class="anchor" href="#implicit-coercion" aria-hidden="true">¶</a> Implicit Coercion</h4>
<ul>
<li><strong><code>a + b</code></strong>: If either is a string, the result is a string. Otherwise, it is
always a numeric adition.</li>
<li><strong><code>a - 0</code></strong>: Coerces <code>a</code> to a number.</li>
<li><strong><code>if (..)</code>, <code>for (; .. ;)</code>, <code>while (..)</code>, <code>? :</code></strong> * --&gt; Boolean.</li>
<li><strong>Note about <code>||</code> and <code>&amp;&amp;</code></strong>: they don’t return a boolean, but select one of
the two operands values:
<ul>
<li><code>||</code>: returns the first if it’s true, the second otherwise.</li>
<li><code>&amp;&amp;</code>: returns the first if it’s false, the second otherwise.</li>
</ul>
</li>
</ul>
<h4 id="loosestrict-equals"><a class="anchor" href="#loosestrict-equals" aria-hidden="true">¶</a> Loose/Strict Equals</h4>
<ul>
<li>
<p>Use <code>==</code> and <code>!=</code> when coercion is desired or makes no difference.</p>
</li>
<li>
<p>Use <code>===</code> and <code>!==</code> when type coercion is not desired.</p>
</li>
<li>
<p>Implicit coercion also happens when using <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> and <code>&lt;=</code>.</p>
</li>
<li>
<p><strong>Abstract Equality rules</strong>:</p>
<ul>
<li><code>string</code>/<code>number</code>: string is coerced to <code>number</code>.</li>
<li>*/<code>boolean</code>: <code>boolean</code> is coerced to <code>number</code>.</li>
<li><code>null</code>/<code>undefined</code>: returns <code>true</code>.</li>
<li>*/<code>null</code> or */<code>undefined</code>: returns <code>false</code>.</li>
<li><code>object</code>/non-<code>object</code>: non-<code>object</code> is to <code>ToPrimitive(object)</code>.</li>
</ul>
</li>
<li>
<p><em>Never</em> compare to <code>== false</code>.</p>
</li>
<li>
<p>*Bad list`:</p>
<ul>
<li><code>&quot;&quot; == 0</code></li>
<li><code>&quot;&quot; == []</code></li>
<li><code>0 == []</code></li>
</ul>
</li>
</ul>
<h3 id="grammar"><a class="anchor" href="#grammar" aria-hidden="true">¶</a> Grammar</h3>
<ul>
<li><code>{a: 42}</code> isn’t an object, but a block with a labeled statement.</li>
<li>The author discourages using labeled statements.</li>
<li>ES6 supports object destructuring: <code>{a, b} = {a: 42, b: &quot;foo&quot;}</code>.</li>
<li>“If the JS parser parses a line where a parser error would occur (a missing
expected <code>;</code>), and it can reasonably insert one, it does so.”</li>
<li>Author: “use semicolons wherever you know they are ‘required’, and limit your
assumptions about ASI to a minimum.”</li>
</ul>
<h2 id="async-performance"><a class="anchor" href="#async-performance" aria-hidden="true">¶</a> Async &amp; Performance</h2>
<h3 id="async"><a class="anchor" href="#async" aria-hidden="true">¶</a> Async</h3>
<ul>
<li>JavaScript executes asynchronous code in an “Event Loop”.</li>
<li>Each iteration of the loop is a “tick”: user interaction, IO, timers… they
all enqueue events.</li>
<li>Only one event is processed at a time.</li>
<li>Sometimes “processes” should “cooperate” by breaking themselves into smaller
chunks to allow other “processes” interleaving.
e.g. Through <code>setTimeout(.., 0)</code>.</li>
<li>JS uses <strong>callbacks</strong> as the “building block” of asynchrony.
<ul>
<li>It is a nonlinear way of thinking.</li>
<li>Leads to “trust issues”: someone else is continuing your program execution.</li>
</ul>
</li>
<li><strong>Promises</strong> (ES6):
<ul>
<li>They resolve those trust issues.</li>
<li><code>new Promise(fn(resolve, reject))</code> can be used to create to create Promises
using <code>resolve(..)</code> and <code>reject(..)</code> inside <code>fn</code>.</li>
<li><code>Promise.all([..])</code> can be used to handle multiple Promises together. Other
variations of Promise patterns exist.</li>
<li><code>Promise.race([..])</code> can be used to timeout Promises.</li>
<li><code>Promise.resolve(..)</code> wraps values and thenables.</li>
<li><code>.then(..)</code> returns a promise: we can also chain Promises.</li>
<li>End chains with <code>.catch(..)</code> to handle errors.</li>
</ul>
</li>
<li><strong>Generators</strong> (ES6):
<ul>
<li><em>I haven’t read this part yet.</em></li>
</ul>
</li>
</ul>
<h3 id="performance"><a class="anchor" href="#performance" aria-hidden="true">¶</a> Performance</h3>
<ul>
<li>Ways to increase program performance:
<ul>
<li>Web Workers</li>
<li>SIMD</li>
<li>asm.js</li>
</ul>
</li>
<li>Benchmarking:
<ul>
<li>Benchmark.js is good for measuring.</li>
<li>You should always consider the context.</li>
<li>You should only test non-trivial snippets of code, not tiny optimizations.</li>
<li><a href="https://jsperf.com/">jsPerf</a> measures snippets on multiple environments.</li>
</ul>
</li>
<li>Micro-optmizations or engine-specific details shouldn’t matter in JS.</li>
<li>ES6 defines TCO (Tail Call Optimzation).
<ul>
<li>Optimizes the stack when a function is called at the final <code>return</code>
statement.</li>
</ul>
</li>
</ul>
<h2 id="es6-beyond"><a class="anchor" href="#es6-beyond" aria-hidden="true">¶</a> ES6 &amp; Beyond</h2>
<p><em>I haven’t read this book yet.</em></p>
</article></main><footer>Site last updated: Mon, 25 Jun 2018 13:24:40 GMT.</footer><script src="/script.js"></script><script src="https://unpkg.com/tippy.js@2.5.3/dist/tippy.all.min.js"></script></body></html>