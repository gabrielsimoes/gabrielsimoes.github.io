<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://gabrielsimoes.github.io/</id>
    <title>Gabriel Simões at gabrielsimoes.github.io</title>
    <updated>2018-06-26T02:30:20Z</updated>
    <generator>Feed for Node.js</generator>
    <author>
        <name>Gabriel Simões</name>
        <email>simoes.sgabriel@gmail.com</email>
        <uri>https://gabrielsimoes.github.io/</uri>
    </author>
    <link rel="alternate" href="https://gabrielsimoes.github.io/"/>
    <link rel="self" href="https://gabrielsimoes.github.io/atom.xml"/>
    <subtitle>My personal blog about software development and more.</subtitle>
    <logo>https://gabrielsimoes.github.io/me-rss.jpg</logo>
    <icon>https://gabrielsimoes.github.io/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Generating a static site with Gulp]]></title>
        <id>https://gabrielsimoes.github.io/articles/generating-a-static-site-with-gulp.html</id>
        <link href="https://gabrielsimoes.github.io/articles/generating-a-static-site-with-gulp.html">
        </link>
        <updated>2018-06-16T00:00:00Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[Notes on "You Don't Know JS" by Kyle Simpson]]></title>
        <id>https://gabrielsimoes.github.io/books/you-dont-know-js.html</id>
        <link href="https://gabrielsimoes.github.io/books/you-dont-know-js.html">
        </link>
        <updated>2018-06-07T00:00:00Z</updated>
        <summary type="html"><![CDATA[A great book for learning JS internals.]]></summary>
        <content type="html"><![CDATA[<p>The best way to understand and avoid language “gotchas” is by understanding what
causes them. It’s also a great book to learn how to optimize your JS programs
with very little effort.</p>
<p>I have written a good amount of notes over all the six books. Some may find
these too details, some might find them too shallow. Either way, those notes
cover the whole book series and are meant as a review, so I can learn things
more effectively and quickly review some details.</p>
<!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->
<ul>
<li><a href="https://gabrielsimoes.github.io//#up-going">Up &amp; Going</a></li>
<li><a href="https://gabrielsimoes.github.io//#scope-closures">Scope &amp; Closures</a>
<ul>
<li><a href="https://gabrielsimoes.github.io//#scope-and-lexical-scope">Scope and Lexical Scope</a></li>
<li><a href="https://gabrielsimoes.github.io//#function-and-block-scopes">Function and Block Scopes</a></li>
<li><a href="https://gabrielsimoes.github.io//#closures">Closures</a></li>
<li><a href="https://gabrielsimoes.github.io//#arrow-functions-es6">Arrow Functions (ES6)</a></li>
</ul>
</li>
<li><a href="https://gabrielsimoes.github.io//#this-object-prototypes"><code>this</code> &amp; Object Prototypes</a>
<ul>
<li><a href="https://gabrielsimoes.github.io//#this"><code>this</code></a></li>
<li><a href="https://gabrielsimoes.github.io//#objects">Objects</a></li>
<li><a href="https://gabrielsimoes.github.io//#mixins">Mixins</a></li>
<li><a href="https://gabrielsimoes.github.io//#prototypes">Prototypes</a></li>
<li><a href="https://gabrielsimoes.github.io//#behavior-delegationoloo-objects-linked-to-other-objects">Behavior Delegation/OLOO (objects-linked-to-other-objects)</a></li>
<li><a href="https://gabrielsimoes.github.io//#es6-class">ES6 <code>class</code></a></li>
</ul>
</li>
<li><a href="https://gabrielsimoes.github.io//#types-grammar">Types &amp; Grammar</a>
<ul>
<li><a href="https://gabrielsimoes.github.io//#types">Types</a></li>
<li><a href="https://gabrielsimoes.github.io//#values">Values</a>
<ul>
<li><a href="https://gabrielsimoes.github.io//#arrays">Arrays</a></li>
<li><a href="https://gabrielsimoes.github.io//#strings">Strings</a></li>
<li><a href="https://gabrielsimoes.github.io//#numbers">Numbers</a></li>
<li><a href="https://gabrielsimoes.github.io//#void-operator"><code>void</code> operator</a></li>
<li><a href="https://gabrielsimoes.github.io//#value-vs-reference">Value vs. Reference</a></li>
</ul>
</li>
<li><a href="https://gabrielsimoes.github.io//#natives">Natives</a></li>
<li><a href="https://gabrielsimoes.github.io//#coercion">Coercion</a>
<ul>
<li><a href="https://gabrielsimoes.github.io//#explicit-coercion">Explicit Coercion</a></li>
<li><a href="https://gabrielsimoes.github.io//#implicit-coercion">Implicit Coercion</a></li>
<li><a href="https://gabrielsimoes.github.io//#loosestrict-equals">Loose/Strict Equals</a></li>
</ul>
</li>
<li><a href="https://gabrielsimoes.github.io//#grammar">Grammar</a></li>
</ul>
</li>
<li><a href="https://gabrielsimoes.github.io//#async-performance">Async &amp; Performance</a>
<ul>
<li><a href="https://gabrielsimoes.github.io//#async">Async</a></li>
<li><a href="https://gabrielsimoes.github.io//#performance">Performance</a></li>
</ul>
</li>
<li><a href="https://gabrielsimoes.github.io//#es6-beyond">ES6 &amp; Beyond</a></li>
</ul>
<!-- /TOC -->
<h2 id="up-going"><a class="anchor" href="https://gabrielsimoes.github.io//#up-going" aria-hidden="true">¶</a> Up &amp; Going</h2>
<p>This first book is great for getting started into the series, specially if you
have a shallow understanding of JS internals. That is because each of the other
books will assume you have some basic understanding of the language mechanisms
explained deeply in the other books of the series.</p>
<p>But if you already have a good understanding of the language, maybe it’s best to
just skip to the other books.</p>
<p>Always use the <code>&quot;use strict&quot;;</code> in your code. Keeps code safer and optimized.</p>
<h2 id="scope-closures"><a class="anchor" href="https://gabrielsimoes.github.io//#scope-closures" aria-hidden="true">¶</a> Scope &amp; Closures</h2>
<h3 id="scope-and-lexical-scope"><a class="anchor" href="https://gabrielsimoes.github.io//#scope-and-lexical-scope" aria-hidden="true">¶</a> Scope and Lexical Scope</h3>
<ul>
<li>JavaScript compiles statements kind-of individually and shortly before they
are executed. JS engines also use JIT, lazy compilation and hot compilation.</li>
<li>We can devide JavaScript compilation in three “characters”: Engine, Compiler
and Scope.</li>
<li>Types of Scope look-ups:
<ul>
<li><em>LHS</em>: when the variable is the target of the assignment. If it doesn’t
exist, the <code>Scope</code> creates a new global variable (when strict mode is not
enabled). If strict mode is enabled, it will throw a <code>ReferenceError</code>.</li>
<li><em>RHS</em>: when the variable is the source of the assigment. <code>Engine</code> wants the
value of the variable. If it doesn’t exist, it will throw a
<code>ReferenceError</code>.</li>
</ul>
</li>
<li>JavaScript scopes by using <em>Lexical Scope</em>, as opposed to <em>Dynamic Scope</em>.
This means that the scopes are nested and are solely determined by the code
structure, rather than by the execution stack.</li>
<li>Lexical scope can be cheated at runtime through <code>eval</code> and <code>with</code>, but they
are almost completely disabled in strict mode and the simple fact you are
using them will disable several optimizations. So, <em>don’t use them</em>.</li>
</ul>
<h3 id="function-and-block-scopes"><a class="anchor" href="https://gabrielsimoes.github.io//#function-and-block-scopes" aria-hidden="true">¶</a> Function and Block Scopes</h3>
<ul>
<li>Author recommends using named functions all the time, even in expressions.
Improves code readability and also stack traces.</li>
<li>JavaScript only restricts variable scope inside functions:<pre><code class="language-javascript hljs"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span>;
}

(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> b = <span class="hljs-number">42</span>; })();

<span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// I can access a.</span>
<span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// Error.</span>
</code></pre>
</li>
<li>You should follow the “Principle of Least <s>Privilege</s> Exposure”.</li>
<li><em>IIFEs</em> (Immediately Invoked Function Expressions):
<ul>
<li><code>(function() { ... })();</code></li>
<li><code>(function() { ... }());</code></li>
<li><code>(function(foo) { foo(&quot;bar&quot;); })(function(str) { ... });</code></li>
</ul>
</li>
<li>Use the ES6 keyword <code>let</code> to do block-scoping:<pre><code class="language-javascript hljs">{
  <span class="hljs-keyword">let</span> foo = <span class="hljs-string">"bar"</span>;
}

<span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// ReferenceError</span>
</code></pre>
</li>
<li>Variables declared with <code>let</code> are never hoisted.</li>
<li>This also improves performance, as values are garbage collected earlier.</li>
<li>The <code>const</code> keyword works just like <code>let</code>, but is used for constants.</li>
<li>This ES6 behaviour is transpilled using <code>try/catch</code> blocks.</li>
<li>JavaScript does hoisting with functions and variables. Functions first:<pre><code class="language-javascript hljs">foo();

<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">// Declaration will go up, but not assignment.</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// This will go above everything.</span>
  <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined -- only "a" declaration was hoisted.</span>
}
</code></pre>
</li>
</ul>
<h3 id="closures"><a class="anchor" href="https://gabrielsimoes.github.io//#closures" aria-hidden="true">¶</a> Closures</h3>
<ul>
<li>Loops + Closure:
This code prints <code>6</code> five times:<pre><code class="language-javascript hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) {
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(i); }, i*<span class="hljs-number">100</span>);
}
</code></pre>
You can solve this by using a closure:<pre><code class="language-javascript hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) {
  (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> j = i;
    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(j); }, j*<span class="hljs-number">100</span>);
  })();
}
</code></pre>
You can solve this using <code>let</code>:<pre><code class="language-javascript hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) {
  <span class="hljs-comment">// you could use the `let j = i;` trick here, but...</span>
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(i); }, i*<span class="hljs-number">100</span>);
}
</code></pre>
There’s a <em>special behaviour</em> defined for <code>let</code> declarations used in the head
of a for-loop: the variable is declared <em>each iteration</em> and it’s initialized
with the value from the previous iteration.</li>
<li><em>Closures</em>: when a function can remember and access its lexical scope even
when it’s invoked outside its lexical scope.</li>
<li><em>Modules</em> require two characteristics:
<ul>
<li>An outer wrapper function being invoked, to create the enclosing scope.</li>
<li>The return value of the function should include a reference to at least one
inner function that then has closure over the private inner scope.</li>
</ul>
<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> foo = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyCoolModule</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> a, b, c;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{ ... };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAnother</span>(<span class="hljs-params"></span>) </span>{ ... };

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">doSomething</span>: doSomething,
    <span class="hljs-attr">doAnother</span>: doAnother
  };
})();
</code></pre>
</li>
<li>You can use ES6 file modules through <code>export</code>, <code>import</code> and <code>module</code>.</li>
</ul>
<h3 id="arrow-functions-es6"><a class="anchor" href="https://gabrielsimoes.github.io//#arrow-functions-es6" aria-hidden="true">¶</a> Arrow Functions (ES6)</h3>
<ul>
<li>They bind <code>this</code> to the lexical context they are in:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> id = <span class="hljs-string">"not awesome"</span>;

<span class="hljs-keyword">var</span> bad = {
  <span class="hljs-attr">id</span>: <span class="hljs-string">"awesome"</span>,
  <span class="hljs-attr">cool</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">coolFn</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.id);
  }
};

<span class="hljs-keyword">var</span> good1 = {
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">cool</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">coolFn</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &lt; <span class="hljs-number">1</span>) {
      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">// arrow-function ftw?</span>
        <span class="hljs-keyword">this</span>.count++;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"awesome?"</span>);
      }, <span class="hljs-number">100</span> );
    }
  }
};

<span class="hljs-keyword">var</span> good2 = {
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">cool</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">coolFn</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.count &lt; <span class="hljs-number">1</span>) {
      setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timer</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">this</span>.count++; <span class="hljs-comment">// `this` is safe because of `bind(..)`</span>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"more awesome"</span>);
      }.bind(<span class="hljs-keyword">this</span>), <span class="hljs-number">100</span> ); <span class="hljs-comment">// look, `bind()`!</span>
    }
  }
};

bad.cool(); <span class="hljs-comment">// awesome</span>
setTimeout(bad.cool, <span class="hljs-number">100</span>); <span class="hljs-comment">// not awesome</span>
good1.cool(); <span class="hljs-comment">// awesome?</span>
good2.cool(); <span class="hljs-comment">// more awesome</span>
</code></pre>
</li>
</ul>
<h2 id="this-object-prototypes"><a class="anchor" href="https://gabrielsimoes.github.io//#this-object-prototypes" aria-hidden="true">¶</a> <code>this</code> &amp; Object Prototypes</h2>
<h3 id="this"><a class="anchor" href="https://gabrielsimoes.github.io//#this" aria-hidden="true">¶</a> <code>this</code></h3>
<ul>
<li>
<p><code>this</code> <em>isn’t</em> a reference to the function itself.</p>
</li>
<li>
<p><code>this</code> <em>isn’t</em> a reference to the function’s lexical scope.</p>
</li>
<li>
<p><code>this</code> <em>is</em> a binding that is made when a function is <em>invoked</em>, and what it
references is determined by the call-site.</p>
</li>
<li>
<p>There are four rules for how <code>this</code> gets set:</p>
<pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.bar);
}

<span class="hljs-keyword">var</span> bar = <span class="hljs-string">"global"</span>;

<span class="hljs-keyword">var</span> obj1 = {
  <span class="hljs-attr">bar</span>: <span class="hljs-string">"obj1"</span>,
  <span class="hljs-attr">foo</span>: foo
};

<span class="hljs-keyword">var</span> obj2 = {
  <span class="hljs-attr">bar</span>: <span class="hljs-string">"obj2"</span>
};

foo();            <span class="hljs-comment">// "global"</span>
obj1.foo();       <span class="hljs-comment">// "obj1"</span>
foo.call( obj2 ); <span class="hljs-comment">// "obj2"</span>
<span class="hljs-keyword">new</span> foo();        <span class="hljs-comment">// undefined</span>
</code></pre>
<ol>
<li><em>Default Binding</em>: Standalone function invocation. In the example above,
<code>foo()</code> ends up setting this to the global object in non-strict mode. In
strict mode, <code>this</code> would be undefined.</li>
<li><em>Implicit Binding</em>: The call-site has a context object. In the example
above, <code>obj1.foo()</code> sets <code>this</code> to the <code>obj1</code> object.</li>
<li><em>Explicit Binding</em>: Using <code>fn.call()</code>, <code>fn.apply()</code> or ES5’s <code>fn.bind()</code>.
In the example above, <code>foo.call(obj2)</code> sets <code>this</code> to the <code>obj2</code> object.
Some API functions have a parameter “context” to be bound in callbacks.</li>
<li><em><code>new</code> Binding</em>: When a function is called with <code>new</code>, a brand new object
is created and set as <code>this</code>. Unless the function returns something, the
new object is returned. In the example above, <code>new foo()</code> sets <code>this</code> to a
brand new empty object.</li>
</ol>
</li>
<li>
<p><em>Binding exceptions</em>:</p>
<ul>
<li>Passing <code>null</code> or <code>undefined</code> to <code>call</code>, <code>apply</code> or <code>bind</code>. Use instead:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> ø = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>); <span class="hljs-comment">// a "DMZ" empty object</span>
fn.bind(ø);
</code></pre>
</li>
<li>Indirection: <code>(p.foo = o.foo)();</code></li>
</ul>
</li>
<li>
<p><em>“Soft Binding”</em>:
Allows overriding with Implicit/Explicit Binding.</p>
<pre><code class="language-javascript hljs"><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Function</span>.prototype.softBind) {
  <span class="hljs-built_in">Function</span>.prototype.softBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
    <span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">this</span>,
      curried = [].slice.call( <span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span> ),
      bound = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bound</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> fn.apply(
          (!<span class="hljs-keyword">this</span> ||
            (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">"undefined"</span> &amp;&amp;
              <span class="hljs-keyword">this</span> === <span class="hljs-built_in">window</span>) ||
            (<span class="hljs-keyword">typeof</span> global !== <span class="hljs-string">"undefined"</span> &amp;&amp;
              <span class="hljs-keyword">this</span> === global)
          ) ? obj : <span class="hljs-keyword">this</span>,
          curried.concat.apply( curried, <span class="hljs-built_in">arguments</span> )
        );
      };
    bound.prototype = <span class="hljs-built_in">Object</span>.create( fn.prototype );
    <span class="hljs-keyword">return</span> bound;
  };
}
</code></pre>
</li>
<li>
<p>It is possible to do lexical binding through arrow functions, but the author
discourages it.</p>
</li>
</ul>
<h3 id="objects"><a class="anchor" href="https://gabrielsimoes.github.io//#objects" aria-hidden="true">¶</a> Objects</h3>
<ul>
<li>In objects, property names are <em>always strings</em>:<pre><code class="language-javscript hljs">myObject[myObject] = 42;
myObject[&quot;[object Object]&quot;]; // 42
</code></pre>
</li>
<li>ES6 computed property names:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> prefix = <span class="hljs-string">"foo"</span>;

<span class="hljs-keyword">var</span> myObject = {
  [prefix + <span class="hljs-string">"bar"</span>]: <span class="hljs-string">"hello"</span>,
  [prefix + <span class="hljs-string">"baz"</span>]: <span class="hljs-string">"world"</span>
};

myObject[<span class="hljs-string">"foobar"</span>]; <span class="hljs-comment">// hello</span>
myObject[<span class="hljs-string">"foobaz"</span>]; <span class="hljs-comment">// world</span>
</code></pre>
</li>
<li>Methods “don’t exist” in JS, only references to functions.</li>
<li>Duplicating objects.
<ul>
<li>JSON-safe objects:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj));
</code></pre>
</li>
<li>Shallow copy (ES6):<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">Object</span>.assign({}, obj);
</code></pre>
</li>
</ul>
</li>
<li>Property Descriptors: <code>Object.getOwnPropertyDescriptor</code>,
<code>Object.defineProperty</code>. The descriptors are: <code>writable</code>, <code>configurable</code> and
<code>enumberable</code>.</li>
<li><code>Object.preventExtensions</code>, <code>Object.seal</code>, <code>Object.freeze</code> to make “immutable”
objects.</li>
<li><code>[[Get]]</code> and <code>[[Set]]</code> characteristics of a property:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> obj = {
  get a() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._a_; },
  set a(val) { <span class="hljs-keyword">this</span>._a_ = val * <span class="hljs-number">2</span>; }
};

<span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">"b"</span>, {
  <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a * <span class="hljs-number">2</span> },
  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
});

obj.a = <span class="hljs-number">1</span>;
obj.a; <span class="hljs-comment">// 2;</span>
obj.b; <span class="hljs-comment">// 4;</span>
</code></pre>
</li>
<li>Test for existence: <code>(&quot;a&quot; in obj);</code> (includes prototypes),
<code>obj.hasOwnProperty(&quot;a&quot;)</code>.</li>
<li>Array of keys: <code>Object.keys</code> (enumerable only), <code>Object.getOwnPropertyNames</code>.</li>
<li>Iterate over keys: <code>for..in</code> loop (includes prototypes). Use in objects, not
arrays. Also: <code>obj.forEach</code>, <code>obj.every</code> and <code>obj.some</code>.</li>
<li>Iterate over values (ES6): <code>for..of</code>.
<ul>
<li>Works by accessing the built-in <code>@@iterator</code>:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> it = myArray[<span class="hljs-built_in">Symbol</span>.iterator]();
it.next(). <span class="hljs-comment">// {value: 42, done: false}</span>
</code></pre>
</li>
<li>It is possible to define custom iterators for objects:<pre><code class="language-javascript hljs"><span class="hljs-built_in">Object</span>.defineProperty( myObject, <span class="hljs-built_in">Symbol</span>.iterator, {
  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">this</span>, i = <span class="hljs-number">0</span>, k = <span class="hljs-built_in">Object</span>.keys(o);
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> {;
          value: o[k[i++]],
          <span class="hljs-attr">done</span>: (i &gt; k.length)
        };
      }
    };
  }
});
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="mixins"><a class="anchor" href="https://gabrielsimoes.github.io//#mixins" aria-hidden="true">¶</a> Mixins</h3>
<ul>
<li>JS has no notion of classes/inheritance/polymorphism.</li>
<li>Developers use mixings instead:<pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mixin</span>(<span class="hljs-params">sourceObj, targetObj</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> sourceObj) {
    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> targetObj)) {
      targetObj[key] = sourceObj[key];
    }
  }

  <span class="hljs-keyword">return</span> targetObj;
}
</code></pre>
</li>
<li>This leads to “explicit pseudo-polymorphism” (which the author discourages):<pre><code class="language-javascript hljs">sourceObj.methodName.call(<span class="hljs-keyword">this</span>, ...);
</code></pre>
</li>
<li>Explicit mixings are not exactly the same as class <em>copy</em>.</li>
<li>“Parasitic Inheritance”: calling <code>new Parent()</code> inside <code>new Child()</code>.</li>
<li>“Implicit Mixings”: “borrowing” methods through “implicit binding”.</li>
</ul>
<h3 id="prototypes"><a class="anchor" href="https://gabrielsimoes.github.io//#prototypes" aria-hidden="true">¶</a> Prototypes</h3>
<ul>
<li><code>Object.create(obj)</code> (ES5) creates a object with <code>obj</code> in <code>[[Prototype]]</code>
linkage.</li>
<li><code>Object.prototype</code> is at the top of every “<em>normal</em>” <code>[[Prototype]]</code> chain.</li>
<li>Shadowing only occurs if the property found in the <code>[[Prototype]]</code> chain is
writable and it is not a setter.</li>
<li>A function’s <code>Foo.prototype</code> gets linked to the <code>[[Prototype]]</code> chain of an
object created with <code>new Foo();</code>:<pre><code class="language-javascript hljs"><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-keyword">new</span> Foo()) === Foo.prototype; <span class="hljs-comment">// true</span>
</code></pre>
</li>
<li><code>Foo.prototype</code> and the created object (through <code>[[Prototype]]</code>) get a
<code>.constructor</code> property:<pre><code class="language-javascript hljs">Foo.prototype.constructor === Foo; <span class="hljs-comment">// true</span>
(<span class="hljs-keyword">new</span> Foo()).constructor === Foo; <span class="hljs-comment">// true</span>
</code></pre>
</li>
<li>However, <code>.constructor</code> is unreliable and should be avoided where possible.</li>
<li>We’re are not actually <em>copying</em> but <em>linking</em> “classes”.</li>
<li>How to simulate class-orientation then? Example from the book:<pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">this</span>.name = name;
}

Foo.prototype.myName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">name,label</span>) </span>{
  Foo.call(<span class="hljs-keyword">this</span>, name);
  <span class="hljs-keyword">this</span>.label = label;
}

<span class="hljs-comment">// here, we make a new `Bar.prototype`</span>
<span class="hljs-comment">// linked to `Foo.prototype`</span>
Bar.prototype = <span class="hljs-built_in">Object</span>.create(Foo.prototype);

<span class="hljs-comment">// Beware! Now `Bar.prototype.constructor` is gone,</span>
<span class="hljs-comment">// and might need to be manually "fixed" if you're</span>
<span class="hljs-comment">// in the habit of relying on such properties!</span>

Bar.prototype.myLabel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.label;
};

<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Bar(<span class="hljs-string">"a"</span>, <span class="hljs-string">"obj a"</span>);

a.myName(); <span class="hljs-comment">// "a"</span>
a.myLabel(); <span class="hljs-comment">// "obj a"</span>
</code></pre>
</li>
<li>Alternatives to <code>Bar.prototype = Object.create(Foo.prototype);</code>:
<ul>
<li><code>Bar.prototype = Foo.prototype;</code>: not a copy, will modify <code>Foo.prototype</code>.</li>
<li><code>Bar.prototype = new Foo();</code>: if <code>Foo()</code> has side-effects, they will happen.</li>
<li>ES6’s <code>Object.setPrototypeOf(Bar.prototype, Foo.prototype);</code>: works well.</li>
</ul>
</li>
<li><code>a instanceof Foo</code> tests whether <code>Foo.prototype</code> appears in the
<code>[[Prototype]]</code> chain of <code>a</code>.</li>
<li>Functions hard-bound with <code>.bind(..)</code> loose their <code>.prototype</code> property.</li>
<li>A much cleaner approach is to use <code>Foo.prototype.isPrototypeOf(a)</code>.</li>
<li>Retrieve <code>[[Prototype]]</code> of an object: <code>Object.getPrototypeOf(a);</code> (ES5) or
<code>a.__proto__</code>.</li>
<li>You <em>should not</em> change the <code>[[Prototype]]</code> of an existing object.</li>
</ul>
<h3 id="behavior-delegationoloo-objects-linked-to-other-objects"><a class="anchor" href="https://gabrielsimoes.github.io//#behavior-delegationoloo-objects-linked-to-other-objects" aria-hidden="true">¶</a> Behavior Delegation/OLOO (objects-linked-to-other-objects)</h3>
<ul>
<li>An alternative way of thinking/designing software in JS, which the author
thinks is better than Object Orientation.</li>
<li>Objects <em>delegate</em> common behaviour to a common prototype through <code>Object.create(..)</code>.</li>
<li>You want <em>state</em> to be on the <em>delegators</em>.</li>
<li><em>We avoid if at all possible naming things the same</em> at different levels of the <code>[[Prototype]]</code> chain.</li>
<li>Code gets much nicer when using <code>Object.setPrototypeOf(obj, prototypeObj)</code>.</li>
<li>We often can eliminate base classes, because behavior delegation suggests
objects as peer of each other.</li>
</ul>
<h3 id="es6-class"><a class="anchor" href="https://gabrielsimoes.github.io//#es6-class" aria-hidden="true">¶</a> ES6 <code>class</code></h3>
<ul>
<li>No need for <code>.prototype</code> references in the code.</li>
<li><code>extends</code> keyword provides inheritance. It is also possible to extend built-in
objects.</li>
<li><code>constructor</code> method provides “instantiation”.</li>
<li><code>super(..)</code> and <code>super.fn(..)</code> provide “<em>relative polmorphism</em>”.</li>
<li>No need for commas.</li>
<li><em>However</em>, it works mostly the same way as the <code>[[Prototype]]</code> mechanism.</li>
<li><em>But</em> it makes some things “static” where otherwise they would be dynamic.</li>
</ul>
<h2 id="types-grammar"><a class="anchor" href="https://gabrielsimoes.github.io//#types-grammar" aria-hidden="true">¶</a> Types &amp; Grammar</h2>
<h3 id="types"><a class="anchor" href="https://gabrielsimoes.github.io//#types" aria-hidden="true">¶</a> Types</h3>
<ul>
<li>JavaScript has only seven built-in types: <code>string</code>, <code>number</code>, <code>boolean</code>,
<code>null</code>, <code>undefined</code>, <code>object</code> and <code>symbol</code> (introduced in ES6).</li>
<li>All are called “primitives”, except for <code>object</code>.</li>
<li><code>typeof</code> has a long-standing bug, but there is a workaround.<pre><code class="language-javascript hljs"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// "object"`</span>

<span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;
(!a &amp;&amp; <span class="hljs-keyword">typeof</span> a === <span class="hljs-string">"object"</span>); <span class="hljs-comment">// true</span>
</code></pre>
</li>
<li><code>function</code> is a (special) subtype of <code>object</code>:<pre><code class="language-javascript hljs"><span class="hljs-keyword">typeof</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; } <span class="hljs-comment">// "function"</span>

<span class="hljs-comment">// but:</span>
<span class="hljs-keyword">typeof</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-comment">// "object"</span>
</code></pre>
</li>
<li>“In JS, variables don’t have types – values have types.”</li>
<li>We can use <code>typeof</code> to prevent errors with undeclared variables, without
resorting to the global <code>window</code> object:<pre><code class="language-javascript hljs"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> FLAG !== <span class="hljs-string">"undefined"</span>) {}
<span class="hljs-comment">// or:</span>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.FLAG) {}
</code></pre>
</li>
</ul>
<h3 id="values"><a class="anchor" href="https://gabrielsimoes.github.io//#values" aria-hidden="true">¶</a> Values</h3>
<h4 id="arrays"><a class="anchor" href="https://gabrielsimoes.github.io//#arrays" aria-hidden="true">¶</a> Arrays</h4>
<ul>
<li><code>delete</code> removes slots but does not update <code>.length</code>.</li>
<li>Adding named properties to arrays doesn’t affect the <code>length</code> property, except
if the property “looks like a number”: <code>myArray[&quot;42&quot;] = &quot;foo&quot;;</code>.</li>
<li>Empty slots are left in this case. They return <code>undefined</code> when accessed.</li>
<li>Build arrays from “array-likes”:<pre><code class="language-javascript hljs"><span class="hljs-built_in">Array</span>.prototype.slice.call([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-comment">// or (ES6):</span>
<span class="hljs-built_in">Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// [1, 2, 3]</span>
</code></pre>
</li>
</ul>
<h4 id="strings"><a class="anchor" href="https://gabrielsimoes.github.io//#strings" aria-hidden="true">¶</a> Strings</h4>
<ul>
<li>JS <code>string</code>s are immutable.</li>
<li>There are some array-like methods, but other array methods are not available.</li>
<li>It is possible to “borrow” some <code>array</code> methods:<pre><code class="language-javascript hljs"><span class="hljs-built_in">Array</span>.prototype.join.call(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"-"</span>); <span class="hljs-comment">// "f-o-o"</span>
<span class="hljs-built_in">Array</span>.prototype.map.call(<span class="hljs-string">"foo"</span>, v =&gt; v.toUpperCase() + <span class="hljs-string">"."</span>).join(<span class="hljs-string">""</span>); <span class="hljs-comment">// "F.O.O."</span>
</code></pre>
</li>
</ul>
<h4 id="numbers"><a class="anchor" href="https://gabrielsimoes.github.io//#numbers" aria-hidden="true">¶</a> Numbers</h4>
<ul>
<li>JS <code>number</code>s use the “IEEE 754” standard (“double precision”), often called
“floating-point.”</li>
<li>Comparisons can fail due to imprecision. Use the <code>Number.EPSILON</code> (ES6) or
<code>2^-52</code> to test equality.</li>
<li>Safe integers (no errors): <code>Number.MAX_SAFE_INTEGER</code> or <code>2^53 -1</code>.</li>
<li>Force a <code>number</code> into a 32-bit signed integer: <code>x | 0</code>. (bitwise operation).</li>
<li>Special numbers:
<ul>
<li><code>NaN</code>:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> a = <span class="hljs-number">42</span> / <span class="hljs-string">"foo"</span>;

a == <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// false</span>
a === <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// false -- comparisons with NaN always return false.</span>

<span class="hljs-comment">// we can use isNaN(..), but it has gotchas:</span>
<span class="hljs-built_in">isNaN</span>(a); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">"foo"</span>) <span class="hljs-comment">// true</span>

<span class="hljs-comment">// ES6:</span>
<span class="hljs-built_in">Number</span>.isNaN(a); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">Number</span>.isNan(<span class="hljs-string">"foo"</span>); <span class="hljs-comment">// false</span>
</code></pre>
</li>
<li><code>Infinity</code> and <code>-Infinity</code>:<pre><code class="language-javascript hljs"><span class="hljs-number">1</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// Infinity</span>
<span class="hljs-number">-1</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// -Infinity</span>
<span class="hljs-number">1e1000000</span>; <span class="hljs-comment">// Infinity</span>
<span class="hljs-number">2</span> * <span class="hljs-built_in">Number</span>.MAX_VALUE; <span class="hljs-comment">// Infinity</span>
</code></pre>
</li>
<li><code>-0</code>: happens as result of some operations, but behaves almost like <code>0</code>:<pre><code class="language-javascript hljs"><span class="hljs-number">-0</span> === <span class="hljs-number">0</span>; <span class="hljs-comment">// true</span>
(<span class="hljs-number">-0</span> === <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-number">1</span> / <span class="hljs-number">-0</span> === -<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// true -- can be used to test for -0</span>
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="void-operator"><a class="anchor" href="https://gabrielsimoes.github.io//#void-operator" aria-hidden="true">¶</a> <code>void</code> operator</h4>
<ul>
<li>“voids” out any value: <code>void &quot;foo&quot;; // undefined</code></li>
</ul>
<h4 id="value-vs-reference"><a class="anchor" href="https://gabrielsimoes.github.io//#value-vs-reference" aria-hidden="true">¶</a> Value vs. Reference</h4>
<ul>
<li>Simple scalar primitives (<code>string</code>s, <code>number</code>s, etc.) are assigned/passed by
value-copy.</li>
<li>Compound values (<code>object</code>s, etc.) are assigned/passed by reference-copy.</li>
<li>References are not like references/pointers in other languages. They point to
the underlying values and not to the variables themselves:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> b = a;

b.push(<span class="hljs-number">4</span>);
a; <span class="hljs-comment">// [1, 2, 3, 4]</span>

b = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
a; <span class="hljs-comment">// [1, 2, 3, 4]</span>

b = a.slice();
b.push(<span class="hljs-number">5</span>);
a; <span class="hljs-comment">// [1, 2, 3, 4]</span>
b; <span class="hljs-comment">// [1, 2, 3, 4, 5]</span>
</code></pre>
</li>
<li>Be careful with object wrappers:<pre><code class="language-javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>{
  x++;
  <span class="hljs-built_in">console</span>.log(x);
}

<span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Number</span>(<span class="hljs-number">42</span>);
foo(a); <span class="hljs-comment">// 43</span>
a; <span class="hljs-comment">// 42</span>
</code></pre>
Even though we’re passing the reference, the underlying value is unboxed from
the <code>Number</code> object in the addition operation.</li>
</ul>
<h3 id="natives"><a class="anchor" href="https://gabrielsimoes.github.io//#natives" aria-hidden="true">¶</a> Natives</h3>
<ul>
<li>
<p>Object sub-types/built-in objects/natives: <code>String()</code>, <code>Number()</code>,
<code>Boolean()</code>, <code>Array()</code>, <code>Object()</code>, <code>Function()</code>, <code>RegExp()</code>, <code>Date()</code>,
<code>Error()</code>, <code>Symbol()</code> (added in ES6).</p>
</li>
<li>
<p>JavaScript automatically coerces primitives to their corresponding objects
when accessing properties/methods:</p>
<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> strPrimitive = <span class="hljs-string">"I am a string"</span>;
<span class="hljs-built_in">console</span>.log(strPrimitive.length);    <span class="hljs-comment">// 13</span>
<span class="hljs-built_in">console</span>.log(strPrimitive.charAt(<span class="hljs-number">3</span>)); <span class="hljs-comment">// "m"</span>
</code></pre>
</li>
<li>
<p>The following objects have corresponding primitives: <code>String</code>, <code>Number</code>,
<code>Boolean</code>.</p>
</li>
<li>
<p><code>null</code> and <code>undefined</code> have no object wrapper form.</p>
</li>
<li>
<p><code>Object</code>, <code>Function</code>, <code>Array</code> and <code>RegExp</code> are object-only, though you should
prefer their literal form.</p>
</li>
<li>
<p><code>Date</code> and <code>Error</code> can only be created through their constructed object form.</p>
</li>
<li>
<p>You should never wrap primitive values manually.</p>
</li>
<li>
<p>There are gotchas, like this one: <code>!(new Boolean(false)); // false</code>.</p>
</li>
<li>
<p>Unboxing: <code>.valueOf()</code>.</p>
</li>
<li>
<p><em>Never use empty-slot arrays</em>. They are full ob bugs/inconsistencies</p>
</li>
<li>
<p>If you want to create an array with “empty” slots, use this:</p>
<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, {<span class="hljs-attr">length</span>: <span class="hljs-number">3</span>});
</code></pre>
<p>It’ll create an array with 3 slots filled with <code>undefined</code>, which is more
reliable then using <code>Array(3)</code> or setting the <code>.length</code> property to 3.</p>
</li>
<li>
<p>You probably should never use <code>Object(..)</code>, <code>Function(..)</code>, and <code>RegExp(..)</code>.</p>
</li>
<li>
<p>Except if you want to pass flags to <code>RegExp(..)</code>, like this:</p>
<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> namePattern = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">"\\b(?:"</span> + name + <span class="hljs-string">")+\\b"</span>, <span class="hljs-string">"ig"</span> );
</code></pre>
</li>
</ul>
<h3 id="coercion"><a class="anchor" href="https://gabrielsimoes.github.io//#coercion" aria-hidden="true">¶</a> Coercion</h3>
<ul>
<li>ToString: <code>a + &quot;&quot;</code>, <code>String(..)</code>, <code>.toString()</code> or <code>JSON.stringify(..)</code></li>
<li>ToNumber: <code>Number(..)</code></li>
<li>ToBoolean: <code>Boolean(..)</code></li>
<li>“Falsy” values:
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>+0</code>, <code>-0</code>, and <code>NaN</code></li>
<li><code>&quot;&quot;</code></li>
</ul>
</li>
<li>Due to legacy reasons, all these coerce to <code>true</code>:<pre><code class="language-javascript hljs"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">0</span>);
<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">""</span>);
</code></pre>
</li>
</ul>
<h4 id="explicit-coercion"><a class="anchor" href="https://gabrielsimoes.github.io//#explicit-coercion" aria-hidden="true">¶</a> Explicit Coercion</h4>
<ul>
<li><strong>Strings &lt;–&gt; Numbers</strong>: <code>String(42)</code> and <code>Number(&quot;42&quot;)</code>.
<ul>
<li><em>Important</em>: Don’t use the <code>new</code> keyword, to avoid creating an object.</li>
<li>Alternative ways: <code>(42).toString()</code> and <code>+&quot;42&quot;</code></li>
<li><code>parseInt(..)</code> and <code>parseFloat(..)</code> are tolerant to non-numeric characters.</li>
<li>Date --&gt; Number: works the same way, the result is the unix timestamp.
<ul>
<li>A explicit approach is better: <code>.getTime()</code>. or <code>Date.now()</code> (ES5).</li>
</ul>
</li>
</ul>
</li>
<li><strong>–&gt; Boolean</strong>: <code>!!x</code> or <code>Boolean(..)</code> (former is preferred)</li>
</ul>
<h4 id="implicit-coercion"><a class="anchor" href="https://gabrielsimoes.github.io//#implicit-coercion" aria-hidden="true">¶</a> Implicit Coercion</h4>
<ul>
<li><strong><code>a + b</code></strong>: If either is a string, the result is a string. Otherwise, it is
always a numeric adition.</li>
<li><strong><code>a - 0</code></strong>: Coerces <code>a</code> to a number.</li>
<li><strong><code>if (..)</code>, <code>for (; .. ;)</code>, <code>while (..)</code>, <code>? :</code></strong> * --&gt; Boolean.</li>
<li><strong>Note about <code>||</code> and <code>&amp;&amp;</code></strong>: they don’t return a boolean, but select one of
the two operands values:
<ul>
<li><code>||</code>: returns the first if it’s true, the second otherwise.</li>
<li><code>&amp;&amp;</code>: returns the first if it’s false, the second otherwise.</li>
</ul>
</li>
</ul>
<h4 id="loosestrict-equals"><a class="anchor" href="https://gabrielsimoes.github.io//#loosestrict-equals" aria-hidden="true">¶</a> Loose/Strict Equals</h4>
<ul>
<li>
<p>Use <code>==</code> and <code>!=</code> when coercion is desired or makes no difference.</p>
</li>
<li>
<p>Use <code>===</code> and <code>!==</code> when type coercion is not desired.</p>
</li>
<li>
<p>Implicit coercion also happens when using <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> and <code>&lt;=</code>.</p>
</li>
<li>
<p><strong>Abstract Equality rules</strong>:</p>
<ul>
<li><code>string</code>/<code>number</code>: string is coerced to <code>number</code>.</li>
<li>*/<code>boolean</code>: <code>boolean</code> is coerced to <code>number</code>.</li>
<li><code>null</code>/<code>undefined</code>: returns <code>true</code>.</li>
<li>*/<code>null</code> or */<code>undefined</code>: returns <code>false</code>.</li>
<li><code>object</code>/non-<code>object</code>: non-<code>object</code> is to <code>ToPrimitive(object)</code>.</li>
</ul>
</li>
<li>
<p><em>Never</em> compare to <code>== false</code>.</p>
</li>
<li>
<p>*Bad list`:</p>
<ul>
<li><code>&quot;&quot; == 0</code></li>
<li><code>&quot;&quot; == []</code></li>
<li><code>0 == []</code></li>
</ul>
</li>
</ul>
<h3 id="grammar"><a class="anchor" href="https://gabrielsimoes.github.io//#grammar" aria-hidden="true">¶</a> Grammar</h3>
<ul>
<li><code>{a: 42}</code> isn’t an object, but a block with a labeled statement.</li>
<li>The author discourages using labeled statements.</li>
<li>ES6 supports object destructuring: <code>{a, b} = {a: 42, b: &quot;foo&quot;}</code>.</li>
<li>“If the JS parser parses a line where a parser error would occur (a missing
expected <code>;</code>), and it can reasonably insert one, it does so.”</li>
<li>Author: “use semicolons wherever you know they are ‘required’, and limit your
assumptions about ASI to a minimum.”</li>
</ul>
<h2 id="async-performance"><a class="anchor" href="https://gabrielsimoes.github.io//#async-performance" aria-hidden="true">¶</a> Async &amp; Performance</h2>
<h3 id="async"><a class="anchor" href="https://gabrielsimoes.github.io//#async" aria-hidden="true">¶</a> Async</h3>
<ul>
<li>JavaScript executes asynchronous code in an “Event Loop”.</li>
<li>Each iteration of the loop is a “tick”: user interaction, IO, timers… they
all enqueue events.</li>
<li>Only one event is processed at a time.</li>
<li>Sometimes “processes” should “cooperate” by breaking themselves into smaller
chunks to allow other “processes” interleaving.
e.g. Through <code>setTimeout(.., 0)</code>.</li>
<li>JS uses <strong>callbacks</strong> as the “building block” of asynchrony.
<ul>
<li>It is a nonlinear way of thinking.</li>
<li>Leads to “trust issues”: someone else is continuing your program execution.</li>
</ul>
</li>
<li><strong>Promises</strong> (ES6):
<ul>
<li>They resolve those trust issues.</li>
<li><code>new Promise(fn(resolve, reject))</code> can be used to create to create Promises
using <code>resolve(..)</code> and <code>reject(..)</code> inside <code>fn</code>.</li>
<li><code>Promise.all([..])</code> can be used to handle multiple Promises together. Other
variations of Promise patterns exist.</li>
<li><code>Promise.race([..])</code> can be used to timeout Promises.</li>
<li><code>Promise.resolve(..)</code> wraps values and thenables.</li>
<li><code>.then(..)</code> returns a promise: we can also chain Promises.</li>
<li>End chains with <code>.catch(..)</code> to handle errors.</li>
</ul>
</li>
<li><strong>Generators</strong> (ES6):
<ul>
<li><em>I haven’t read this part yet.</em></li>
</ul>
</li>
</ul>
<h3 id="performance"><a class="anchor" href="https://gabrielsimoes.github.io//#performance" aria-hidden="true">¶</a> Performance</h3>
<ul>
<li>Ways to increase program performance:
<ul>
<li>Web Workers</li>
<li>SIMD</li>
<li>asm.js</li>
</ul>
</li>
<li>Benchmarking:
<ul>
<li>Benchmark.js is good for measuring.</li>
<li>You should always consider the context.</li>
<li>You should only test non-trivial snippets of code, not tiny optimizations.</li>
<li><a href="https://jsperf.com/">jsPerf</a> measures snippets on multiple environments.</li>
</ul>
</li>
<li>Micro-optmizations or engine-specific details shouldn’t matter in JS.</li>
<li>ES6 defines TCO (Tail Call Optimzation).
<ul>
<li>Optimizes the stack when a function is called at the final <code>return</code>
statement.</li>
</ul>
</li>
</ul>
<h2 id="es6-beyond"><a class="anchor" href="https://gabrielsimoes.github.io//#es6-beyond" aria-hidden="true">¶</a> ES6 &amp; Beyond</h2>
<p><em>I haven’t read this book yet.</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Notes on "The Value of Values" by Rich Hickey]]></title>
        <id>https://gabrielsimoes.github.io/talks/the-value-of-values.html</id>
        <link href="https://gabrielsimoes.github.io/talks/the-value-of-values.html">
        </link>
        <updated>2018-05-30T00:00:00Z</updated>
        <summary type="html"><![CDATA[A talk by Rich Hickey about using immutable values over "places".]]></summary>
        <content type="html"><![CDATA[<ul>
<li><em>Values x Places</em></li>
<li><em>Place has no role in an information model</em>, only in implementation</li>
<li>Values are:
<ul>
<li>Immutable</li>
<li>Don’t need methods (to be sent, for example)</li>
</ul>
</li>
<li>Value advantages:
<ul>
<li>Can be shared freely</li>
<li>Reproducible results
<ul>
<li><em>Reproduce failures without replicating states</em></li>
</ul>
</li>
<li>Easy to fabricate (generate compliant values)</li>
<li>Refuse to help you program imperatively</li>
<li>Language independent</li>
<li>Values aggregate to values (value + value = value)</li>
<li>more stuff I didn’t take note…</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Notes on "Simple Made Easy" by Rich Hickey]]></title>
        <id>https://gabrielsimoes.github.io/talks/simple-made-easy.html</id>
        <link href="https://gabrielsimoes.github.io/talks/simple-made-easy.html">
        </link>
        <updated>2018-05-29T00:00:00Z</updated>
        <summary type="html"><![CDATA[A talk on functional programming ideas by Rich Hickey. Simple != Easy.]]></summary>
        <content type="html"><![CDATA[<ul>
<li>We should aim for simplicity because simplicity is a prerequisite for reliability.</li>
<li>Simple != Easy.
<ul>
<li>“Easy” means “to be at hand”, “to be approachable”.</li>
<li>“Simple” is the opposite of “complex” which means “being intertwined”, “being tied together”.</li>
<li>“Simple” is about doing a single thing, not about doing it only once (cardinality).</li>
</ul>
</li>
<li>What matters in software is: does the software do what is supposed to do? Is it of high quality? Can we rely on it? Can problems be fixed along the way? Can requirements change over time? The answers to these questions is what matters in writing software not the look and feel of the experience writing the code or the cultural implications of it.</li>
<li>The benefits of simplicity are: ease of understanding, ease of change, ease of debugging, flexibility.</li>
<li>Complex constructs: State, Object, Methods, Syntax, Inheritance, Switch/matching, Vars, Imperative loops, Actors, ORM, Conditionals.</li>
<li>Simple constructs: Values, Functions, Namespaces, Data, Polymorphism, Managed refs, Set functions, Queues, Declarative data manipulation, Rules, Consistency.</li>
<li>The following constructs are simpler:
<ul>
<li>Values: use final, persistent collections</li>
<li>Functions: use stateless methods</li>
<li>Namespaces: use a language with good support for namespaces</li>
<li>Data: use maps, arrays, sets, XML, JSON, etc.</li>
<li>Polymorphism: through protocols, type classes</li>
<li>Managed Refs: Clojure, Haskell</li>
<li>Set functions: via libraries</li>
<li>Queues: via libraries</li>
<li>Declarative data manipulation: via SQL, LINQ, Datalog</li>
<li>Rules: via libraries or natively in Prolog</li>
</ul>
</li>
<li>Build simple systems by:
<ul>
<li>Abstracting - design by answering questions related to what, who, when, where, why, and how.</li>
<li>Choosing constructs that generate simple artifacts.</li>
<li>Simplify by encapsulation.</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Notes on "Hammock Driven Programming" by Rich Hickey]]></title>
        <id>https://gabrielsimoes.github.io/talks/hammock-driven-programming.html</id>
        <link href="https://gabrielsimoes.github.io/talks/hammock-driven-programming.html">
        </link>
        <updated>2018-05-28T00:00:00Z</updated>
        <summary type="html"><![CDATA[Or how to solve problems/design programs/avoid bugs by Rich Hickey]]></summary>
        <content type="html"><![CDATA[<ul>
<li>Bugs are much cheaper to solve during design.</li>
<li><em>Solve Problem</em> x <em>Create Features</em></li>
<li>Features are results, not objectives.</li>
<li>Solving the problem is what matters</li>
</ul>
<ol>
<li>State the problem: say it out loud or write it down.</li>
<li>Understand: facts, context, constraints.</li>
</ol>
<ul>
<li>What you don’t know?</li>
<li>Related problems out there?</li>
</ul>
<ol start="3">
<li>Discern</li>
</ol>
<ul>
<li>Problems &amp; tradeoffs in your solutions: technical, logical</li>
<li>There should be questions</li>
<li>More input the better: literature, search other solutions.</li>
</ul>
<ol start="4">
<li>Focus</li>
</ol>
<ul>
<li>Get away from computer</li>
<li>Tradeoffs: balls will be dropped</li>
</ul>
<ol start="5">
<li>Waking Mind x Background Mind</li>
</ol>
<ul>
<li>Waking should feed Background.</li>
<li>Make a problem  a days’ agenda to feed it into your background.</li>
<li>Analyze Background output with Waking.</li>
</ul>
<ol start="6">
<li>There is a 7±2 concorruent problem limit on the mind.</li>
</ol>
<ul>
<li>Write the problem down, possibly with pictures.</li>
</ul>
<ol start="7">
<li>Hammock time: NO INPUT! Close your eyes - recall the problem in your imagination.</li>
<li>Wait before getting to work.</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Notes on "Are We There Yet?" by Rich Hickey]]></title>
        <id>https://gabrielsimoes.github.io/talks/are-we-there-yet.html</id>
        <link href="https://gabrielsimoes.github.io/talks/are-we-there-yet.html">
        </link>
        <updated>2018-05-07T00:00:00Z</updated>
        <summary type="html"><![CDATA[Amazing talk by Rich Hickey on fundamental Clojure and Functional Programming concurrency concepts.
]]></summary>
        <content type="html"><![CDATA[<h2 id="introduction"><a class="anchor" href="https://gabrielsimoes.github.io//#introduction" aria-hidden="true">¶</a> Introduction</h2>
<ul>
<li>All OO languages have fundamental things in common:
<ul>
<li>Single-dispatch, stateful OO.</li>
<li>Classes, inheritance, fields, methods, GC</li>
</ul>
</li>
<li>Differences are superficial: syntax, expressivity.</li>
<li>C++:
<ul>
<li>Simple constructs, same syntax for heap/non-heap things.</li>
<li>Complexity: knowing when/if to delete.</li>
<li>No standard automatic memory management.</li>
</ul>
</li>
<li>Java:
<ul>
<li>Simple: only references to dynamic memory + GC.</li>
<li>Complexity: <em>knowing when you’ll see a consistent value</em>.</li>
</ul>
</li>
<li><em>Pure functions are Worry-Free</em></li>
<li><em>But</em> not all programs are pure functions.</li>
</ul>
<h2 id="things-we-are-doing-wrong"><a class="anchor" href="https://gabrielsimoes.github.io//#things-we-are-doing-wrong" aria-hidden="true">¶</a> Things we are doing wrong</h2>
<ul>
<li>We created objects that can <em>change</em> in place.</li>
<li>We left <em>time</em> out.</li>
<li>Our languages have no notion of <em>values</em>.</li>
<li>“No man can cross the same river twice.” - Heraclitus
<ul>
<li>Actual entities are atomic immutable values</li>
<li>The future is a function of the past, it doesn’t change it</li>
<li>We associate <em>identities</em> with a series of causally related values</li>
<li>Time is atomic, epochal succession of process events</li>
</ul>
</li>
<li>Terms
<ul>
<li><em>Value</em>:  An <em>immutable</em> magnitude, quantity, number…</li>
<li><em>Identity</em>: A succession of values whose causation is related.</li>
<li><em>State</em>: <em>Snapshots</em>. Value of an identity at a <em>moment in time</em>.</li>
<li><em>Time</em>: Relative before/after ordering of casual values.</li>
</ul>
</li>
<li><em>Our programs try to “stop time” and know the state of everything to make decisions</em>.
<ul>
<li>Stadium analogy: “wait nobody move let me take a picture of the ball in mid-air”.</li>
</ul>
</li>
<li>Truth is: <em>we are always perceiving the (unchanging!) past</em>.</li>
<li>Our sensory systems have discretization and simultaneity detection.</li>
<li>On the other hand, <em>action has to be sequential</em>.
<ul>
<li>No two things can affect the same thing at the same time.</li>
<li>We have to sort of take turns.</li>
</ul>
</li>
<li>Action and Perception are two different things.</li>
</ul>
<h2 id="epochal-time-model"><a class="anchor" href="https://gabrielsimoes.github.io//#epochal-time-model" aria-hidden="true">¶</a> Epochal Time Model</h2>
<p><img src="are-we-there-yet-epochal-time-model.png" alt="Epochal Time Model" /></p>
<ul>
<li>A point in time is a value - it can’t be changed.</li>
<li>Our program is still organized in identities (succession of states).</li>
<li>We use pure functions to produce the feature.</li>
</ul>
<h2 id="implementation-ideas"><a class="anchor" href="https://gabrielsimoes.github.io//#implementation-ideas" aria-hidden="true">¶</a> Implementation ideas</h2>
<ul>
<li>
<p>We need constructs to represent values.</p>
</li>
<li>
<p>We need constructs to coordinate the succession of values.</p>
</li>
<li>
<p>We should consume memory to model time.</p>
</li>
<li>
<p>GC cleans up longer-referenced ‘past’.</p>
</li>
<li>
<p>Use <em>persistent data structures</em>.</p>
<ul>
<li>They are <em>immutable</em>.</li>
<li>Use trees + path copying.</li>
</ul>
</li>
<li>
<p>Time constructs.</p>
<ul>
<li>Need to ensure atomic state succession.</li>
<li>Need to provide point-in-time perception.</li>
<li>Multiple timelines possible.</li>
<li>Many implementation strategies: CAS, Agents, STM, maybe even locks.</li>
</ul>
</li>
</ul>
<h2 id="cas-compare-and-swap-as-a-time-construct"><a class="anchor" href="https://gabrielsimoes.github.io//#cas-compare-and-swap-as-a-time-construct" aria-hidden="true">¶</a> CAS (Compare and Swap) as a Time Construct.</h2>
<p><img src="are-we-there-yet-cas.png" alt="CAS" /></p>
<ul>
<li>Uncoordinated 1:1.</li>
<li>Replaces state based on comparisons.</li>
</ul>
<h2 id="agents-as-a-time-construct"><a class="anchor" href="https://gabrielsimoes.github.io//#agents-as-a-time-construct" aria-hidden="true">¶</a> Agents as a Time Construct</h2>
<p><img src="are-we-there-yet-agents.png" alt="Agents" /></p>
<ul>
<li>Uncoordinated 1:1.</li>
<li>Replaces state based on a queue through a thread pool.</li>
</ul>
<h2 id="stm-as-a-time-construct"><a class="anchor" href="https://gabrielsimoes.github.io//#stm-as-a-time-construct" aria-hidden="true">¶</a> STM as a Time Construct</h2>
<p><img src="are-we-there-yet-stm-1.png" alt="STM" /></p>
<ul>
<li>Multiple timelines in the same app.</li>
<li>A single transaction affects multiple timelines.</li>
<li>ACI properties of ACID.</li>
</ul>
<p><img src="are-we-there-yet-stm-1.png" alt="STM Perception" /></p>
<ul>
<li>Using a system that uses MVCC (Multi Version Concurrency Control), it is
possible to percept snapshots.</li>
<li>Keep history in order to satisfy readers.</li>
<li>It allows readers to have their own notions of a timeline.</li>
</ul>
]]></content>
    </entry>
</feed>